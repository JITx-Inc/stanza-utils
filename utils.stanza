;; See license.txt for details about licensing.

defpackage utils :
  import core
  import collections
  import math

;;; GENERAL

public defn default<T> (v:T|False, d:T) -> T :
  match(v) :
    (t:False) : d
    (o:T) : o

public defn hex-to-int (s: String) -> Int :
  var res = 0
  for i in 2 to length(s) do :
    val dig = index-of("0123456789ABCDEF", s[i]) as Int
    res = res * 16 + dig
  res

;;; CHARACTERS

public defn digit? (c:Int) -> True|False :
  c >= to-int('0') and c <= to-int('9')

public defn lower? (c:Int) -> True|False :
  c >= to-int('a') and c <= to-int('z')

public defn upper? (c:Int) -> True|False :
  c >= to-int('A') and c <= to-int('Z')

public defn printable? (c:Int) -> True|False :
  c >= to-int(' ') and c <= to-int('~')

public defn upper-case (c:Int) -> Int :
  if lower?(c) :
    c - to-int('a') + to-int('A')
  else :
    c

public defn lower-case (c:Int) -> Int :
  if upper?(c) :
    c - to-int('A') + to-int('a')
  else :
    c

;; public defn digit? (c:Char) -> True|False : digit?(to-int(c))
public defn lower? (c:Char) -> True|False : lower?(to-int(c))
public defn upper? (c:Char) -> True|False : upper?(to-int(c))

public defn trim (s:String, ok?:(Char) -> True|False) -> String :
   match(index-when(ok?, s)) :
      (i:Int) :
         val n = length(s)
         val j = for i in (n - 1) through 0 by -1 find! :
            ok?(s[i])
         s[i through j]   
      (i:False) : ""

public defn split* (str:String, s:String) -> Seq<String> :
   generate<String> :
      val strl = length(str)
      val sl = length(s)
      defn loop (b:Int) :
         if b < strl :
            match(index-of-chars(str, b to false, s)) :
               (i:Int) :
                  yield(str[b to i])
                  loop(i + sl)
               (i:False) :
                  yield(str[b to false])
      loop(0)

public defn to-array!<?T> (xs:Seqable<?T>) -> Array<T> :
   match(xs) :
      (xs:Seqable<T> & Lengthable) :
         val n = length(xs)
         val a = Array<T>(n)
         for (x in xs, i in 0 to n) do :
            a[i] = x
         a
      (xs) :
         to-array!(to-list(xs))

;;; BUFFERED STREAM

public deftype BufferedInputStream <: InputStream
public defmulti peek? (s:BufferedInputStream) -> Char|False

public defn BufferedInputStream (s:InputStream) :
  var buf = false
  new BufferedInputStream :
    defmethod get-char (this) :
      match(buf) :
        (f:False): get-char(s)
        (c:Char):  (buf = false, c)
    defmethod peek? (this) :
      match(buf) :
        (f:False): (buf = get-char(s), buf)
        (c:Char):  c

public defn get-chars-while (ss:BufferedInputStream, f:(Char) -> True|False) -> String :
  val buffer = StringBuffer()
  while peek?(ss) is Char and f(peek?(ss) as Char) :
    add(buffer, get-char!(ss))
  to-string(buffer)

public defn get-char! (s:BufferedInputStream) -> Char :
  match(get-char(s)) :
    (f:False): fail()
    (c:Char): c

public defn get-chars! (s:BufferedInputStream, n:Int) -> String :
  val buffer = StringBuffer()
  for i in 0 to n do :
    add(buffer, get-char!(s))
  to-string(buffer)

public defn parse-int (s:BufferedInputStream) -> Int :
  val chars = get-chars-while(s, digit?)
  to-int(chars) as Int

public defn expect-char (s:BufferedInputStream, c:Char) -> False :
  val gc = get-char(s)
  if gc != c: fatal("Expected %_ got %_" % [c, gc])

