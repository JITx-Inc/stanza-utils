defpackage edits :
  import core
  import collections

public var *trace-edits?*:True|False = false
val *edit-ids* = to-seq(0 to false)
public defn next-edit-id () : next(*edit-ids*)

public defstruct Edit :
  name : String
  id : Int with: (init => next-edit-id())
  edit-redo : () -> ?
  edit-undo : () -> ?

public defn redo (e:Edit) : edit-redo(e)()
public defn undo (e:Edit) : edit-undo(e)()

public defn SlotEdit (name:String, object:?, prev:?, next:?, setter:(?, ?) -> False) :
  Edit(name, { setter(object, next) }, { setter(object, prev) })
  
public defstruct Edits :
  index : Int with: (init => 0, setter => set-index)
  marks : Vector<Int> with: (init => Vector<Int>())
  elts : Vector<Edit> with: (init => Vector<Edit>())
with:
  constructor => #Edits

defmethod print (o:OutputStream, e:Edits) :
  print(o, "Edits(%_, %_, %_)" % [index(e), marks(e), length(elts(e))])

public defn Edits () :
  val e = #Edits()
  add(marks(e), 0)
  e

public defn find-next-target (edits:Edits, idx:Int) -> Int :
  let loop (i:Int = 0) :
    if i < length(marks(edits)) :
      if marks(edits)[i] > idx :
        marks(edits)[i]
      else :
        loop(i + 1)
    else :
      length(elts(edits))
           
public defn find-prev-target (edits:Edits, idx:Int) -> [Int, Int] :
  let loop (i:Int = length(marks(edits)) - 1) :
    if i > 0 :
      if marks(edits)[i] < idx :
        [marks(edits)[i], i]
      else :
        loop(i - 1)
    else :
      [0, 0]

public defn undo (edits:Edits) :
  println("UNDOING EDITS %_" % [edits])
  val [target, mark-index] = find-prev-target(edits, index(edits))
  for i in (index(edits) - 1) through target by -1 do :
    println("UNDOING %_ %_" % [i, elts(edits)[i]]) when *trace-edits?*
    undo(elts(edits)[i])
  set-index(edits, target)
  
public defn redo (edits:Edits) :
  println("REDOING EDITS %_" % [edits])
  val next-target = find-next-target(edits, index(edits))
  for i in index(edits) to next-target do :
    redo(elts(edits)[i])
  set-index(edits, next-target)
  
public defn add-mark (edits:Edits) :
  add(marks(edits), index(edits))

public defn clear (edits:Edits) :
  println("CLEARING")
  clear(elts(edits))
  shorten(marks(edits), 1)
  set-index(edits, 0)

defn pop (edits:Edits, idx:Int) :
  val [target, mark-index] = find-prev-target(edits, idx + 1)
  ;; println("POPPING %_ TO TARGET %_ MARK-INDEX %_" % [idx, target, mark-index])
  shorten(marks(edits), mark-index + 1)
  shorten(elts(edits), idx)
  
public defn add (edits:Edits, edit:Edit) :
  pop(edits, index(edits))
  add(elts(edits), edit)
  set-index(edits, length(elts(edits)))
  println("ADD %_ INDEX %_" % [edit, index(edits)]) when *trace-edits?* 

public var *edits*:False|Edits = false

public defn add-edit (e:Edit) :
  add(*edits* as Edits, e) when *edits* is Edits

public defn add-edit (f:() -> Edit) :
  add-edit(f()) when *edits* is Edits

public defn add-do-edit (e:Edit) :
  redo(e)
  add-edit(e)
